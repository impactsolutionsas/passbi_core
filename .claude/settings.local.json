{
  "permissions": {
    "allow": [
      "Bash(wc:*)",
      "Bash(brew install:*)",
      "Bash(brew services start:*)",
      "Bash(pg_ctl:*)",
      "Bash(/usr/local/opt/postgresql@15/bin/postgres:*)",
      "Bash(if [ ! -d \"/usr/local/var/postgresql@15\" ])",
      "Bash(then)",
      "Bash(/usr/local/opt/postgresql@15/bin/initdb:*)",
      "Bash(else)",
      "Bash(fi)",
      "Bash(/usr/local/opt/postgresql@15/bin/pg_ctl:*)",
      "Bash(lsof:*)",
      "Bash(docker:*)",
      "Bash(docker compose:*)",
      "Bash(open:*)",
      "Bash(for i in {1..30})",
      "Bash(do)",
      "Bash(if docker info)",
      "Bash(exit 0)",
      "Bash(echo:*)",
      "Bash(done)",
      "Bash(brew reinstall:*)",
      "Bash(sudo mkdir:*)",
      "Bash(sudo ln:*)",
      "Bash(go mod download:*)",
      "Bash(go mod tidy:*)",
      "Bash(psql:*)",
      "Bash(export PATH=\"/usr/local/opt/postgresql@17/bin:$PATH\")",
      "Bash(migrate:*)",
      "Bash(redis-cli ping:*)",
      "Bash(go run:*)",
      "Bash(export DB_HOST=localhost)",
      "Bash(export DB_PORT=5432)",
      "Bash(export DB_NAME=passbi:*)",
      "Bash(export DB_USER=macpro)",
      "Bash(export:*)",
      "Bash(export REDIS_HOST=localhost)",
      "Bash(export REDIS_PORT=6379)",
      "Bash(export API_PORT=8080)",
      "Bash(curl:*)",
      "Bash(python3:*)",
      "Bash(redis-cli FLUSHALL:*)",
      "Bash(xargs:*)",
      "Bash(go mod init:*)",
      "Bash(go get:*)",
      "Bash(/Users/macpro/Desktop/PASSBI-DEVLAND/passbi_core/query_stops.go << 'EOF'\npackage main\n\nimport \\(\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t_ \"github.com/lib/pq\"\n\\)\n\ntype Stop struct {\n\tID   string\n\tName string\n\tLat  float64\n\tLon  float64\n}\n\nfunc main\\(\\) {\n\t// Database connection details\n\tdbHost := \"localhost\"\n\tdbPort := \"5432\"\n\tdbUser := \"macpro\"\n\tdbPassword := \"\"\n\tdbName := \"passbi\"\n\n\t// Create connection string\n\tconnStr := fmt.Sprintf\\(\"host=%s port=%s user=%s password=%s dbname=%s sslmode=disable\",\n\t\tdbHost, dbPort, dbUser, dbPassword, dbName\\)\n\n\t// Connect to database\n\tdb, err := sql.Open\\(\"postgres\", connStr\\)\n\tif err != nil {\n\t\tlog.Fatal\\(\"Error opening database connection:\", err\\)\n\t}\n\tdefer db.Close\\(\\)\n\n\t// Test connection\n\terr = db.Ping\\(\\)\n\tif err != nil {\n\t\tlog.Fatal\\(\"Error connecting to database:\", err\\)\n\t}\n\n\tfmt.Println\\(\"Successfully connected to PassBi database\"\\)\n\tfmt.Println\\(\"============================================================\"\\)\n\tfmt.Println\\(\"\\\\nQuerying stops served by route D7OP \\(DDD_07\\)...\"\\)\n\tfmt.Println\\(\\)\n\n\t// Execute query\n\tquery := `\n\t\tSELECT DISTINCT s.id, s.name, s.lat, s.lon\n\t\tFROM stop s\n\t\tJOIN node n ON n.stop_id = s.id\n\t\tWHERE n.route_id = 'DDD_07'\n\t\tORDER BY s.id\n\t\tLIMIT 10\n\t`\n\n\trows, err := db.Query\\(query\\)\n\tif err != nil {\n\t\tlog.Fatal\\(\"Error executing query:\", err\\)\n\t}\n\tdefer rows.Close\\(\\)\n\n\t// Print header\n\tfmt.Printf\\(\"%-15s %-40s %-12s %-12s\\\\n\", \"Stop ID\", \"Stop Name\", \"Latitude\", \"Longitude\"\\)\n\tfor i := 0; i < 80; i++ {\n\t\tfmt.Print\\(\"-\"\\)\n\t}\n\tfmt.Println\\(\\)\n\n\t// Fetch and print results\n\tcount := 0\n\tfor rows.Next\\(\\) {\n\t\tvar stop Stop\n\t\terr := rows.Scan\\(&stop.ID, &stop.Name, &stop.Lat, &stop.Lon\\)\n\t\tif err != nil {\n\t\t\tlog.Fatal\\(\"Error scanning row:\", err\\)\n\t\t}\n\n\t\tfmt.Printf\\(\"%-15s %-40s %-12.6f %-12.6f\\\\n\",\n\t\t\tstop.ID, stop.Name, stop.Lat, stop.Lon\\)\n\t\tcount++\n\t}\n\n\t// Check for errors during iteration\n\tif err = rows.Err\\(\\); err != nil {\n\t\tlog.Fatal\\(\"Error iterating rows:\", err\\)\n\t}\n\n\tfmt.Println\\(\\)\n\tfmt.Printf\\(\"Total stops found: %d\\\\n\", count\\)\n}\nEOF)",
      "Bash(/Users/macpro/Desktop/PASSBI-DEVLAND/passbi_core/query_stops.go << 'EOF'\npackage main\n\nimport \\(\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t_ \"github.com/lib/pq\"\n\\)\n\ntype Stop struct {\n\tID   string\n\tName string\n\tLat  float64\n\tLon  float64\n}\n\nfunc main\\(\\) {\n\t// Database connection details from .env\n\tdbHost := \"localhost\"\n\tdbPort := \"5432\"\n\tdbUser := \"macpro\"\n\tdbPassword := \"\"\n\tdbName := \"passbi\"\n\n\t// Create connection string - when password is empty, omit it\n\tconnStr := fmt.Sprintf\\(\"host=%s port=%s user=%s dbname=%s sslmode=disable\",\n\t\tdbHost, dbPort, dbUser, dbName\\)\n\n\t// Connect to database\n\tdb, err := sql.Open\\(\"postgres\", connStr\\)\n\tif err != nil {\n\t\tlog.Fatal\\(\"Error opening database connection:\", err\\)\n\t}\n\tdefer db.Close\\(\\)\n\n\t// Test connection\n\terr = db.Ping\\(\\)\n\tif err != nil {\n\t\tlog.Fatal\\(\"Error connecting to database:\", err\\)\n\t}\n\n\tfmt.Println\\(\"Successfully connected to PassBi database\"\\)\n\tfmt.Println\\(\"============================================================\"\\)\n\tfmt.Println\\(\"\\\\nQuerying stops served by route D7OP \\(DDD_07\\)...\"\\)\n\tfmt.Println\\(\\)\n\n\t// Execute query\n\tquery := `\n\t\tSELECT DISTINCT s.id, s.name, s.lat, s.lon\n\t\tFROM stop s\n\t\tJOIN node n ON n.stop_id = s.id\n\t\tWHERE n.route_id = 'DDD_07'\n\t\tORDER BY s.id\n\t\tLIMIT 10\n\t`\n\n\trows, err := db.Query\\(query\\)\n\tif err != nil {\n\t\tlog.Fatal\\(\"Error executing query:\", err\\)\n\t}\n\tdefer rows.Close\\(\\)\n\n\t// Print header\n\tfmt.Printf\\(\"%-15s %-40s %-12s %-12s\\\\n\", \"Stop ID\", \"Stop Name\", \"Latitude\", \"Longitude\"\\)\n\tfor i := 0; i < 80; i++ {\n\t\tfmt.Print\\(\"-\"\\)\n\t}\n\tfmt.Println\\(\\)\n\n\t// Fetch and print results\n\tcount := 0\n\tfor rows.Next\\(\\) {\n\t\tvar stop Stop\n\t\terr := rows.Scan\\(&stop.ID, &stop.Name, &stop.Lat, &stop.Lon\\)\n\t\tif err != nil {\n\t\t\tlog.Fatal\\(\"Error scanning row:\", err\\)\n\t\t}\n\n\t\tfmt.Printf\\(\"%-15s %-40s %-12.6f %-12.6f\\\\n\",\n\t\t\tstop.ID, stop.Name, stop.Lat, stop.Lon\\)\n\t\tcount++\n\t}\n\n\t// Check for errors during iteration\n\tif err = rows.Err\\(\\); err != nil {\n\t\tlog.Fatal\\(\"Error iterating rows:\", err\\)\n\t}\n\n\tfmt.Println\\(\\)\n\tfmt.Printf\\(\"Total stops found: %d\\\\n\", count\\)\n}\nEOF)",
      "Bash(/Users/macpro/Desktop/PASSBI-DEVLAND/passbi_core/query_stops.go << 'EOF'\npackage main\n\nimport \\(\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t_ \"github.com/lib/pq\"\n\\)\n\ntype Stop struct {\n\tID   string\n\tName string\n\tLat  float64\n\tLon  float64\n}\n\nfunc main\\(\\) {\n\t// Database connection details from .env\n\tdbHost := \"localhost\"\n\tdbPort := \"5432\"\n\tdbUser := \"macpro\"\n\tdbName := \"passbi\"\n\n\t// Create connection string\n\tconnStr := fmt.Sprintf\\(\"host=%s port=%s user=%s dbname=%s sslmode=disable\",\n\t\tdbHost, dbPort, dbUser, dbName\\)\n\n\t// Connect to database\n\tdb, err := sql.Open\\(\"postgres\", connStr\\)\n\tif err != nil {\n\t\tlog.Fatal\\(\"Error opening database connection:\", err\\)\n\t}\n\tdefer db.Close\\(\\)\n\n\t// Test connection\n\terr = db.Ping\\(\\)\n\tif err != nil {\n\t\tlog.Fatal\\(\"Error connecting to database:\", err\\)\n\t}\n\n\tfmt.Println\\(\"Successfully connected to PassBi database\"\\)\n\tfmt.Println\\(\"============================================================\"\\)\n\tfmt.Println\\(\"\\\\nQuerying stops served by route D7OP \\(DDD_07\\)...\"\\)\n\tfmt.Println\\(\\)\n\n\t// Execute query\n\tquery := `\n\t\tSELECT DISTINCT s.id, s.name, s.lat, s.lon\n\t\tFROM stop s\n\t\tJOIN node n ON n.stop_id = s.id\n\t\tWHERE n.route_id = 'DDD_07'\n\t\tORDER BY s.id\n\t\tLIMIT 10\n\t`\n\n\trows, err := db.Query\\(query\\)\n\tif err != nil {\n\t\tlog.Fatal\\(\"Error executing query:\", err\\)\n\t}\n\tdefer rows.Close\\(\\)\n\n\t// Print header\n\tfmt.Printf\\(\"%-15s %-40s %-12s %-12s\\\\n\", \"Stop ID\", \"Stop Name\", \"Latitude\", \"Longitude\"\\)\n\tfor i := 0; i < 80; i++ {\n\t\tfmt.Print\\(\"-\"\\)\n\t}\n\tfmt.Println\\(\\)\n\n\t// Fetch and print results\n\tcount := 0\n\tfor rows.Next\\(\\) {\n\t\tvar stop Stop\n\t\terr := rows.Scan\\(&stop.ID, &stop.Name, &stop.Lat, &stop.Lon\\)\n\t\tif err != nil {\n\t\t\tlog.Fatal\\(\"Error scanning row:\", err\\)\n\t\t}\n\n\t\tfmt.Printf\\(\"%-15s %-40s %-12.6f %-12.6f\\\\n\",\n\t\t\tstop.ID, stop.Name, stop.Lat, stop.Lon\\)\n\t\tcount++\n\t}\n\n\t// Check for errors during iteration\n\tif err = rows.Err\\(\\); err != nil {\n\t\tlog.Fatal\\(\"Error iterating rows:\", err\\)\n\t}\n\n\tfmt.Println\\(\\)\n\tfmt.Printf\\(\"Total stops found: %d\\\\n\", count\\)\n}\nEOF)",
      "Bash(check_d7op_connection.go << 'EOF'\npackage main\n\nimport \\(\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n\\)\n\nfunc main\\(\\) {\n\tconnString := \"host=localhost port=5432 dbname=passbi user=macpro sslmode=disable\"\n\t\n\tpool, err := pgxpool.New\\(context.Background\\(\\), connString\\)\n\tif err != nil {\n\t\tlog.Fatal\\(err\\)\n\t}\n\tdefer pool.Close\\(\\)\n\t\n\t// Check if D7OP connects these two stops\n\tquery := `\n\t\tSELECT COUNT\\(*\\) \n\t\tFROM edge e\n\t\tJOIN node n1 ON n1.id = e.from_node_id\n\t\tJOIN node n2 ON n2.id = e.to_node_id\n\t\tWHERE n1.route_id = 'DDD_07' \n\t\tAND n2.route_id = 'DDD_07'\n\t\tAND n1.stop_id = 'D_1230'\n\t\tAND e.type = 'RIDE'\n\t`\n\t\n\tvar count int\n\terr = pool.QueryRow\\(context.Background\\(\\), query\\).Scan\\(&count\\)\n\tif err != nil {\n\t\tlog.Fatal\\(err\\)\n\t}\n\t\n\tfmt.Printf\\(\"D7OP RIDE edges from Stade De Ouakam \\(D_1230\\): %d\\\\n\", count\\)\n\t\n\t// Check total D7OP RIDE edges\n\tquery2 := `\n\t\tSELECT COUNT\\(*\\) \n\t\tFROM edge e\n\t\tJOIN node n1 ON n1.id = e.from_node_id\n\t\tWHERE n1.route_id = 'DDD_07'\n\t\tAND e.type = 'RIDE'\n\t`\n\t\n\terr = pool.QueryRow\\(context.Background\\(\\), query2\\).Scan\\(&count\\)\n\tif err != nil {\n\t\tlog.Fatal\\(err\\)\n\t}\n\t\n\tfmt.Printf\\(\"Total D7OP RIDE edges: %d\\\\n\", count\\)\n\t\n\t// Get first few RIDE edges from D_1230 on D7OP\n\tquery3 := `\n\t\tSELECT s2.name, s2.lat, s2.lon\n\t\tFROM edge e\n\t\tJOIN node n1 ON n1.id = e.from_node_id\n\t\tJOIN node n2 ON n2.id = e.to_node_id\n\t\tJOIN stop s2 ON s2.id = n2.stop_id\n\t\tWHERE n1.route_id = 'DDD_07'\n\t\tAND n1.stop_id = 'D_1230'\n\t\tAND e.type = 'RIDE'\n\t\tLIMIT 5\n\t`\n\t\n\trows, err := pool.Query\\(context.Background\\(\\), query3\\)\n\tif err != nil {\n\t\tlog.Fatal\\(err\\)\n\t}\n\tdefer rows.Close\\(\\)\n\t\n\tfmt.Println\\(\"\\\\nNext stops from Stade De Ouakam on D7OP:\"\\)\n\tfor rows.Next\\(\\) {\n\t\tvar name string\n\t\tvar lat, lon float64\n\t\trows.Scan\\(&name, &lat, &lon\\)\n\t\tfmt.Printf\\(\"  â†’ %s \\(%.6f, %.6f\\)\\\\n\", name, lat, lon\\)\n\t}\n}\nEOF)",
      "Bash(check_d7op_connection.go << 'EOF'\npackage main\n\nimport \\(\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n\\)\n\nfunc main\\(\\) {\n\tconnString := \"host=localhost port=5432 dbname=passbi user=macpro sslmode=disable\"\n\t\n\tpool, err := pgxpool.New\\(context.Background\\(\\), connString\\)\n\tif err != nil {\n\t\tlog.Fatal\\(err\\)\n\t}\n\tdefer pool.Close\\(\\)\n\t\n\t// Check if D7OP connects these two stops\n\tquery := `\n\t\tSELECT COUNT\\(*\\) \n\t\tFROM edge e\n\t\tJOIN node n1 ON n1.id = e.from_node_id\n\t\tJOIN node n2 ON n2.id = e.to_node_id\n\t\tWHERE n1.route_id = 'DDD_07' \n\t\tAND n2.route_id = 'DDD_07'\n\t\tAND n1.stop_id = 'D_1230'\n\t\tAND e.type = 'RIDE'\n\t`\n\t\n\tvar count int\n\terr = pool.QueryRow\\(context.Background\\(\\), query\\).Scan\\(&count\\)\n\tif err != nil {\n\t\tlog.Fatal\\(err\\)\n\t}\n\t\n\tfmt.Printf\\(\"D7OP RIDE edges from Stade De Ouakam \\(D_1230\\): %d\\\\n\", count\\)\n\t\n\t// Check total D7OP RIDE edges\n\tquery2 := `\n\t\tSELECT COUNT\\(*\\) \n\t\tFROM edge e\n\t\tJOIN node n1 ON n1.id = e.from_node_id\n\t\tWHERE n1.route_id = 'DDD_07'\n\t\tAND e.type = 'RIDE'\n\t`\n\t\n\terr = pool.QueryRow\\(context.Background\\(\\), query2\\).Scan\\(&count\\)\n\tif err != nil {\n\t\tlog.Fatal\\(err\\)\n\t}\n\t\n\tfmt.Printf\\(\"Total D7OP RIDE edges: %d\\\\n\", count\\)\n\t\n\t// Get first few RIDE edges from D_1230 on D7OP\n\tquery3 := `\n\t\tSELECT s2.name, s2.lat, s2.lon\n\t\tFROM edge e\n\t\tJOIN node n1 ON n1.id = e.from_node_id\n\t\tJOIN node n2 ON n2.id = e.to_node_id\n\t\tJOIN stop s2 ON s2.id = n2.stop_id\n\t\tWHERE n1.route_id = 'DDD_07'\n\t\tAND n1.stop_id = 'D_1230'\n\t\tAND e.type = 'RIDE'\n\t\tLIMIT 5\n\t`\n\t\n\trows, err := pool.Query\\(context.Background\\(\\), query3\\)\n\tif err != nil {\n\t\tlog.Fatal\\(err\\)\n\t}\n\tdefer rows.Close\\(\\)\n\t\n\tfmt.Println\\(\"\\\\nNext stops from Stade De Ouakam on D7OP:\"\\)\n\tfor rows.Next\\(\\) {\n\t\tvar name string\n\t\tvar lat, lon float64\n\t\trows.Scan\\(&name, &lat, &lon\\)\n\t\tfmt.Printf\\(\"  â†’ %s \\(%.6f, %.6f\\)\\\\n\", name, lat, lon\\)\n\t}\n}\nEOF)",
      "Bash(compare_routes.go << 'EOF'\npackage main\n\nimport \\(\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n\\)\n\nfunc main\\(\\) {\n\tconnString := \"host=localhost port=5432 dbname=passbi user=macpro sslmode=disable\"\n\t\n\tpool, err := pgxpool.New\\(context.Background\\(\\), connString\\)\n\tif err != nil {\n\t\tlog.Fatal\\(err\\)\n\t}\n\tdefer pool.Close\\(\\)\n\t\n\t// Find all routes connecting D_1230 to the next stop\n\tquery := `\n\t\tSELECT \n\t\t\tr.short_name,\n\t\t\te.cost_time,\n\t\t\te.type\n\t\tFROM edge e\n\t\tJOIN node n1 ON n1.id = e.from_node_id\n\t\tJOIN node n2 ON n2.id = e.to_node_id\n\t\tJOIN route r ON r.id = n1.route_id\n\t\tWHERE n1.stop_id = 'D_1230'\n\t\tAND n2.stop_id IN \\(\n\t\t\tSELECT DISTINCT n2b.stop_id \n\t\t\tFROM edge e2\n\t\t\tJOIN node n1b ON n1b.id = e2.from_node_id\n\t\t\tJOIN node n2b ON n2b.id = e2.to_node_id\n\t\t\tWHERE n1b.stop_id = 'D_1230' \n\t\t\tAND n1b.route_id = 'DDD_07'\n\t\t\tAND e2.type = 'RIDE'\n\t\t\tLIMIT 1\n\t\t\\)\n\t\tAND e.type = 'RIDE'\n\t\tORDER BY r.short_name\n\t`\n\t\n\trows, err := pool.Query\\(context.Background\\(\\), query\\)\n\tif err != nil {\n\t\tlog.Fatal\\(err\\)\n\t}\n\tdefer rows.Close\\(\\)\n\t\n\tfmt.Println\\(\"Routes connecting Stade De Ouakam to next stop:\"\\)\n\tfmt.Println\\(\"Route         Cost \\(seconds\\)    Type\"\\)\n\tfmt.Println\\(\"------------------------------------------\"\\)\n\tfor rows.Next\\(\\) {\n\t\tvar route string\n\t\tvar cost int\n\t\tvar edgeType string\n\t\trows.Scan\\(&route, &cost, &edgeType\\)\n\t\tfmt.Printf\\(\"%-12s  %-15d   %s\\\\n\", route, cost, edgeType\\)\n\t}\n}\nEOF)",
      "Bash(find_d7op_only_stops.go << 'EOF'\npackage main\n\nimport \\(\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n\\)\n\nfunc main\\(\\) {\n\tconnString := \"host=localhost port=5432 dbname=passbi user=macpro sslmode=disable\"\n\t\n\tpool, err := pgxpool.New\\(context.Background\\(\\), connString\\)\n\tif err != nil {\n\t\tlog.Fatal\\(err\\)\n\t}\n\tdefer pool.Close\\(\\)\n\t\n\t// Find stops served ONLY by D7OP \\(or where D7OP is one of very few routes\\)\n\tquery := `\n\t\tWITH stop_routes AS \\(\n\t\t\tSELECT \n\t\t\t\ts.id,\n\t\t\t\ts.name,\n\t\t\t\ts.lat,\n\t\t\t\ts.lon,\n\t\t\t\tCOUNT\\(DISTINCT n.route_id\\) as route_count,\n\t\t\t\tMAX\\(CASE WHEN n.route_id = 'DDD_07' THEN 1 ELSE 0 END\\) as has_d7op\n\t\t\tFROM stop s\n\t\t\tJOIN node n ON n.stop_id = s.id\n\t\t\tGROUP BY s.id, s.name, s.lat, s.lon\n\t\t\\)\n\t\tSELECT id, name, lat, lon, route_count\n\t\tFROM stop_routes\n\t\tWHERE has_d7op = 1\n\t\tAND route_count <= 3\n\t\tORDER BY route_count, id\n\t\tLIMIT 10\n\t`\n\t\n\trows, err := pool.Query\\(context.Background\\(\\), query\\)\n\tif err != nil {\n\t\tlog.Fatal\\(err\\)\n\t}\n\tdefer rows.Close\\(\\)\n\t\n\tfmt.Println\\(\"Stops served by D7OP \\(with few competing routes\\):\"\\)\n\tfmt.Println\\(\"Stop ID    Name                                    Lat         Lon         Routes\"\\)\n\tfmt.Println\\(\"-----------------------------------------------------------------------------------------\"\\)\n\tfor rows.Next\\(\\) {\n\t\tvar id, name string\n\t\tvar lat, lon float64\n\t\tvar routeCount int\n\t\trows.Scan\\(&id, &name, &lat, &lon, &routeCount\\)\n\t\tfmt.Printf\\(\"%-10s %-40s %-11.6f %-11.6f %d\\\\n\", id, name, lat, lon, routeCount\\)\n\t}\n}\nEOF)",
      "Bash(find_pure_d7op_connection.go << 'EOF'\npackage main\n\nimport \\(\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n\\)\n\nfunc main\\(\\) {\n\tconnString := \"host=localhost port=5432 dbname=passbi user=macpro sslmode=disable\"\n\t\n\tpool, err := pgxpool.New\\(context.Background\\(\\), connString\\)\n\tif err != nil {\n\t\tlog.Fatal\\(err\\)\n\t}\n\tdefer pool.Close\\(\\)\n\t\n\t// Find a D7OP connection where the FROM stop has D7OP as one of few routes\n\tquery := `\n\t\tWITH d7op_edges AS \\(\n\t\t\tSELECT DISTINCT\n\t\t\t\tn1.stop_id as from_stop,\n\t\t\t\tn2.stop_id as to_stop,\n\t\t\t\ts1.name as from_name,\n\t\t\t\ts2.name as to_name,\n\t\t\t\ts1.lat as from_lat,\n\t\t\t\ts1.lon as from_lon,\n\t\t\t\ts2.lat as to_lat,\n\t\t\t\ts2.lon as to_lon,\n\t\t\t\te.cost_time\n\t\t\tFROM edge e\n\t\t\tJOIN node n1 ON n1.id = e.from_node_id\n\t\t\tJOIN node n2 ON n2.id = e.to_node_id\n\t\t\tJOIN stop s1 ON s1.id = n1.stop_id\n\t\t\tJOIN stop s2 ON s2.id = n2.stop_id\n\t\t\tWHERE n1.route_id = 'DDD_07'\n\t\t\tAND n2.route_id = 'DDD_07'\n\t\t\tAND e.type = 'RIDE'\n\t\t\\),\n\t\tstop_route_counts AS \\(\n\t\t\tSELECT stop_id, COUNT\\(DISTINCT route_id\\) as route_count\n\t\t\tFROM node\n\t\t\tGROUP BY stop_id\n\t\t\\)\n\t\tSELECT \n\t\t\td.from_stop,\n\t\t\td.to_stop,\n\t\t\td.from_name,\n\t\t\td.to_name,\n\t\t\td.from_lat,\n\t\t\td.from_lon,\n\t\t\td.to_lat,\n\t\t\td.to_lon,\n\t\t\ts1.route_count as from_routes,\n\t\t\ts2.route_count as to_routes\n\t\tFROM d7op_edges d\n\t\tJOIN stop_route_counts s1 ON s1.stop_id = d.from_stop\n\t\tJOIN stop_route_counts s2 ON s2.stop_id = d.to_stop\n\t\tWHERE s1.route_count <= 3 AND s2.route_count <= 3\n\t\tORDER BY s1.route_count + s2.route_count, d.from_stop\n\t\tLIMIT 5\n\t`\n\t\n\trows, err := pool.Query\\(context.Background\\(\\), query\\)\n\tif err != nil {\n\t\tlog.Fatal\\(err\\)\n\t}\n\tdefer rows.Close\\(\\)\n\t\n\tfmt.Println\\(\"D7OP connections with minimal competition:\"\\)\n\tfmt.Println\\(\\)\n\ti := 1\n\tfor rows.Next\\(\\) {\n\t\tvar fromStop, toStop, fromName, toName string\n\t\tvar fromLat, fromLon, toLat, toLon float64\n\t\tvar fromRoutes, toRoutes int\n\t\trows.Scan\\(&fromStop, &toStop, &fromName, &toName, &fromLat, &fromLon, &toLat, &toLon, &fromRoutes, &toRoutes\\)\n\t\tfmt.Printf\\(\"Option %d:\\\\n\", i\\)\n\t\tfmt.Printf\\(\"  From: %s \\(%.6f, %.6f\\) [%d routes]\\\\n\", fromName, fromLat, fromLon, fromRoutes\\)\n\t\tfmt.Printf\\(\"  To:   %s \\(%.6f, %.6f\\) [%d routes]\\\\n\", toName, toLat, toLon, toRoutes\\)\n\t\tfmt.Println\\(\\)\n\t\ti++\n\t}\n}\nEOF)",
      "Bash(compare_a67_d7op.go << 'EOF'\npackage main\n\nimport \\(\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n\\)\n\nfunc main\\(\\) {\n\tconnString := \"host=localhost port=5432 dbname=passbi user=macpro sslmode=disable\"\n\t\n\tpool, err := pgxpool.New\\(context.Background\\(\\), connString\\)\n\tif err != nil {\n\t\tlog.Fatal\\(err\\)\n\t}\n\tdefer pool.Close\\(\\)\n\t\n\t// Get nearest nodes to origin for each route\n\tquery := `\n\t\tSELECT \n\t\t\tn.route_id,\n\t\t\tr.short_name,\n\t\t\ts.name,\n\t\t\ts.lat,\n\t\t\ts.lon,\n\t\t\tST_Distance\\(s.geom, ST_SetSRID\\(ST_MakePoint\\(-17.481408, 14.708902\\), 4326\\)\\) as dist\n\t\tFROM node n\n\t\tJOIN stop s ON s.id = n.stop_id\n\t\tJOIN route r ON r.id = n.route_id\n\t\tWHERE n.route_id IN \\('DDD_07', 'AFTU_67'\\)\n\t\tAND ST_DWithin\\(s.geom, ST_SetSRID\\(ST_MakePoint\\(-17.481408, 14.708902\\), 4326\\), 100\\)\n\t\tORDER BY n.route_id, dist\n\t\tLIMIT 10\n\t`\n\t\n\trows, err := pool.Query\\(context.Background\\(\\), query\\)\n\tif err != nil {\n\t\tlog.Fatal\\(err\\)\n\t}\n\tdefer rows.Close\\(\\)\n\t\n\tfmt.Println\\(\"Nearest nodes to origin \\(14.708902, -17.481408\\):\"\\)\n\tfmt.Println\\(\"Route      Route Name  Stop Name                           Distance \\(m\\)\"\\)\n\tfmt.Println\\(\"-----------------------------------------------------------------------------\"\\)\n\tfor rows.Next\\(\\) {\n\t\tvar routeID, routeName, stopName string\n\t\tvar lat, lon, dist float64\n\t\trows.Scan\\(&routeID, &routeName, &stopName, &lat, &lon, &dist\\)\n\t\tfmt.Printf\\(\"%-10s %-11s %-35s %.1f\\\\n\", routeID, routeName, stopName, dist\\)\n\t}\n}\nEOF)",
      "Bash(compare_edge_costs.go << 'EOF'\npackage main\n\nimport \\(\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n\\)\n\nfunc main\\(\\) {\n\tconnString := \"host=localhost port=5432 dbname=passbi user=macpro sslmode=disable\"\n\t\n\tpool, err := pgxpool.New\\(context.Background\\(\\), connString\\)\n\tif err != nil {\n\t\tlog.Fatal\\(err\\)\n\t}\n\tdefer pool.Close\\(\\)\n\t\n\t// Get edge costs for both routes from origin area to destination area\n\tquery := `\n\t\tSELECT \n\t\t\tr.short_name,\n\t\t\ts1.name as from_stop,\n\t\t\ts2.name as to_stop,\n\t\t\te.cost_time,\n\t\t\te.cost_walk,\n\t\t\te.cost_transfer,\n\t\t\te.type\n\t\tFROM edge e\n\t\tJOIN node n1 ON n1.id = e.from_node_id\n\t\tJOIN node n2 ON n2.id = e.to_node_id\n\t\tJOIN route r ON r.id = n1.route_id\n\t\tJOIN stop s1 ON s1.id = n1.stop_id\n\t\tJOIN stop s2 ON s2.id = n2.stop_id\n\t\tWHERE n1.route_id IN \\('DDD_07', 'AFTU_67'\\)\n\t\tAND ST_DWithin\\(s1.geom, ST_SetSRID\\(ST_MakePoint\\(-17.481408, 14.708902\\), 4326\\), 20\\)\n\t\tAND ST_DWithin\\(s2.geom, ST_SetSRID\\(ST_MakePoint\\(-17.473310, 14.702426\\), 4326\\), 20\\)\n\t\tAND e.type = 'RIDE'\n\t\tORDER BY r.short_name, e.cost_time\n\t\tLIMIT 10\n\t`\n\t\n\trows, err := pool.Query\\(context.Background\\(\\), query\\)\n\tif err != nil {\n\t\tlog.Fatal\\(err\\)\n\t}\n\tdefer rows.Close\\(\\)\n\t\n\tfmt.Println\\(\"RIDE edges from origin area to destination area:\"\\)\n\tfmt.Println\\(\"Route      From -> To                                    Time  Walk  Trans  Type\"\\)\n\tfmt.Println\\(\"----------------------------------------------------------------------------------------\"\\)\n\tfor rows.Next\\(\\) {\n\t\tvar route, fromStop, toStop, edgeType string\n\t\tvar costTime, costWalk, costTransfer int\n\t\trows.Scan\\(&route, &fromStop, &toStop, &costTime, &costWalk, &costTransfer, &edgeType\\)\n\t\tfmt.Printf\\(\"%-10s %-45s %-5d %-5d %-6d %s\\\\n\", route, fromStop+\" -> \"+toStop, costTime, costWalk, costTransfer, edgeType\\)\n\t}\n}\nEOF)",
      "Bash(go test:*)",
      "Bash(test_prod_connection.go << 'EOF'\npackage main\n\nimport \\(\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\t\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n\\)\n\nfunc main\\(\\) {\n\tconnString := \"host=db.xlvuggzprjjkzolonbuh.supabase.co port=5432 dbname=postgres user=postgres password=Mounty@890911 sslmode=require\"\n\t\n\tctx, cancel := context.WithTimeout\\(context.Background\\(\\), 10*time.Second\\)\n\tdefer cancel\\(\\)\n\t\n\tpool, err := pgxpool.New\\(ctx, connString\\)\n\tif err != nil {\n\t\tlog.Fatalf\\(\"âŒ Unable to create connection pool: %v\", err\\)\n\t}\n\tdefer pool.Close\\(\\)\n\t\n\t// Test connection\n\tif err := pool.Ping\\(ctx\\); err != nil {\n\t\tlog.Fatalf\\(\"âŒ Unable to ping database: %v\", err\\)\n\t}\n\t\n\tfmt.Println\\(\"âœ… Successfully connected to Supabase production database!\"\\)\n\t\n\t// Check PostgreSQL version\n\tvar version string\n\terr = pool.QueryRow\\(ctx, \"SELECT version\\(\\)\"\\).Scan\\(&version\\)\n\tif err != nil {\n\t\tlog.Fatalf\\(\"âŒ Unable to query version: %v\", err\\)\n\t}\n\tfmt.Printf\\(\"ðŸ“¦ PostgreSQL: %s\\\\n\", version[:50]\\)\n\t\n\t// Check PostGIS extension\n\tvar hasPostGIS bool\n\terr = pool.QueryRow\\(ctx, \"SELECT EXISTS\\(SELECT 1 FROM pg_extension WHERE extname = 'postgis'\\)\"\\).Scan\\(&hasPostGIS\\)\n\tif err != nil {\n\t\tlog.Fatalf\\(\"âŒ Unable to check PostGIS: %v\", err\\)\n\t}\n\t\n\tif hasPostGIS {\n\t\tvar postgisVersion string\n\t\terr = pool.QueryRow\\(ctx, \"SELECT PostGIS_Version\\(\\)\"\\).Scan\\(&postgisVersion\\)\n\t\tif err == nil {\n\t\t\tfmt.Printf\\(\"ðŸŒ PostGIS: %s\\\\n\", postgisVersion\\)\n\t\t}\n\t} else {\n\t\tfmt.Println\\(\"âš ï¸  PostGIS extension not installed\"\\)\n\t}\n\t\n\t// Check existing tables\n\tvar tableCount int\n\terr = pool.QueryRow\\(ctx, `\n\t\tSELECT COUNT\\(*\\) \n\t\tFROM information_schema.tables \n\t\tWHERE table_schema = 'public' \n\t\tAND table_type = 'BASE TABLE'\n\t`\\).Scan\\(&tableCount\\)\n\tif err != nil {\n\t\tlog.Fatalf\\(\"âŒ Unable to count tables: %v\", err\\)\n\t}\n\tfmt.Printf\\(\"ðŸ“Š Existing tables: %d\\\\n\", tableCount\\)\n}\nEOF)",
      "Bash(test_prod_connection2.go << 'EOF'\npackage main\n\nimport \\(\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\t\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n\\)\n\nfunc main\\(\\) {\n\t// Try with connection pooler \\(port 6543\\)\n\tconnStrings := []string{\n\t\t\"postgresql://postgres:Mounty@890911@db.xlvuggzprjjkzolonbuh.supabase.co:6543/postgres?sslmode=require\",\n\t\t\"postgresql://postgres.xlvuggzprjjkzolonbuh:Mounty@890911@aws-0-eu-central-1.pooler.supabase.com:6543/postgres?sslmode=require\",\n\t}\n\t\n\tfor i, connString := range connStrings {\n\t\tfmt.Printf\\(\"\\\\nðŸ”„ Tentative %d...\\\\n\", i+1\\)\n\t\t\n\t\tctx, cancel := context.WithTimeout\\(context.Background\\(\\), 10*time.Second\\)\n\t\t\n\t\tpool, err := pgxpool.New\\(ctx, connString\\)\n\t\tif err != nil {\n\t\t\tcancel\\(\\)\n\t\t\tfmt.Printf\\(\"âŒ Unable to create pool: %v\\\\n\", err\\)\n\t\t\tcontinue\n\t\t}\n\t\t\n\t\tif err := pool.Ping\\(ctx\\); err != nil {\n\t\t\tpool.Close\\(\\)\n\t\t\tcancel\\(\\)\n\t\t\tfmt.Printf\\(\"âŒ Unable to ping: %v\\\\n\", err\\)\n\t\t\tcontinue\n\t\t}\n\t\t\n\t\tfmt.Println\\(\"âœ… Successfully connected!\"\\)\n\t\t\n\t\tvar version string\n\t\tif err := pool.QueryRow\\(ctx, \"SELECT version\\(\\)\"\\).Scan\\(&version\\); err == nil {\n\t\t\tfmt.Printf\\(\"ðŸ“¦ PostgreSQL: %s\\\\n\", version[:60]\\)\n\t\t}\n\t\t\n\t\tpool.Close\\(\\)\n\t\tcancel\\(\\)\n\t\treturn\n\t}\n\t\n\tlog.Fatal\\(\"\\\\nâŒ All connection attempts failed\"\\)\n}\nEOF)",
      "Bash(chmod:*)"
    ]
  }
}
